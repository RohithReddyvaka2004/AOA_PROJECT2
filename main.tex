\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{theorem}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}

% Listings configuration for code
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    breakatwhitespace=true,
    columns=flexible,
    keepspaces=true,
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    xleftmargin=10pt,
    xrightmargin=5pt,
    language=C++,
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    stringstyle=\color{red}
}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{Polynomial Reductions in Ecology and Bioinformatics: Wildlife Corridor Design via Network Flow and DNA Sequence Assembly via Hamiltonian Path}

\author{
\IEEEauthorblockN{Rohith Reddy Vaka}
\IEEEauthorblockA{
vakarohithreddy@ufl.edu\\
University of Florida\\
Gainesville, FL, USA
}
\and
\IEEEauthorblockN{Venkata Deepika Potu}
\IEEEauthorblockA{
vpotu@ufl.edu\\
University of Florida\\
Gainesville, FL, USA
}
}

\maketitle

\begin{abstract}
We study two fundamental computational problems through polynomial-time reductions. For the polynomial-time case, we implement Wildlife Corridor Network Design for endangered species conservation and demonstrate its reduction to Maximum Flow, achieving optimal solutions via the Edmonds-Karp algorithm with verified $O(V^2E)$ complexity. For the NP-complete case, we formalize the DNA Fragment Assembly Problem and prove its NP-completeness through reduction from Hamiltonian Path. We implement three greedy heuristics—Simple Greedy, Nearest Neighbor, and Savings Algorithm—and experimentally verify that the Savings approach achieves 20-25\% better overlap than simple greedy while maintaining polynomial runtime. Experiments validate theoretical complexity bounds; code and experimental data are released.
\end{abstract}

\begin{IEEEkeywords}
maximum flow, NP-completeness, Hamiltonian path, conservation ecology, bioinformatics, polynomial reduction, greedy algorithms
\end{IEEEkeywords}

\section{Introduction}

The theory of computational complexity provides a rigorous framework for understanding the inherent difficulty of computational problems. Two fundamental problem classes emerge from this theory: problems solvable in polynomial time (P) and NP-complete problems, which are believed to require exponential time in the worst case.

This paper investigates two real-world problems from conservation biology and genomics domains, demonstrating how theoretical computer science techniques can be applied to solve critical challenges in natural sciences. We make the following contributions:

\begin{enumerate}
\item We formalize the Wildlife Corridor Network Design Problem and provide a polynomial-time reduction to Maximum Flow.
\item We prove the NP-completeness of the DNA Fragment Assembly Problem by reduction from Hamiltonian Path.
\item We implement efficient algorithms for both problems and provide comprehensive experimental validation of the theoretical complexity bounds.
\item We compare multiple greedy heuristics for the NP-complete problem and analyze their performance characteristics.
\end{enumerate}

\subsection{Related Work}

The Maximum Flow problem has been extensively studied since the seminal work of Ford and Fulkerson \cite{ford1956}. The Edmonds-Karp algorithm \cite{edmonds1972} provides an $O(VE^2)$ implementation using breadth-first search. Applications of network flow to ecological connectivity have been explored in landscape ecology \cite{urban2001}.

The DNA fragment assembly problem has been studied since the 1980s \cite{waterman1995}. The overlap-layout-consensus paradigm remains standard \cite{myers2000}, though modern assemblers use de Bruijn graphs \cite{pevzner2001}. The computational complexity was established by reduction to Hamiltonian Path \cite{kececioglu1995}.

\section{Problem 1: Wildlife Corridor Design}

\subsection{Problem Description}

Wildlife corridors are protected land strips connecting fragmented habitats, enabling animal movement, genetic exchange, and population stability. The Wildlife Corridor Network Design Problem involves determining optimal corridor placement to maximize endangered species movement between isolated habitat patches.

\begin{definition}[Wildlife Corridor Network Design Problem]
Given:
\begin{itemize}
\item A set $H = \{h_1, h_2, \ldots, h_n\}$ of $n$ habitat patches
\item Spatial locations $(x_i, y_i)$ for each habitat $h_i$
\item A maximum feasible corridor distance $d_{max}$
\item Source habitat $h_s$ (main reserve) and target habitat $h_t$ (secondary reserve)
\end{itemize}
Objective: Determine a corridor network that maximizes animal flow from $h_s$ to $h_t$ given terrain and distance constraints.
\end{definition}

\subsection{Real-World Context}

This problem arises in conservation planning for:
\begin{itemize}
\item African elephants requiring migration routes across fragmented savannas,
\item Florida panthers connecting Everglades habitat patches,
\item Grizzly bears linking Yellowstone to Yukon wilderness,
\item Tigers moving between Indian national parks.
\end{itemize}

Corridor capacity depends on terrain suitability, development density, and species-specific movement behavior.

\subsection{Abstract Problem Formulation}

We model the landscape as a graph where:
\begin{itemize}
\item Each habitat patch $h_i$ is a vertex,
\item Potential corridors between patches are edges,
\item Edge capacity represents maximum sustainable animal flow (animals/year),
\item Capacity decreases with distance due to terrain difficulty.
\end{itemize}

Capacity is defined as:
\[
c(h_i, h_j) = 
\begin{cases}
C_{max}\left(1 - \frac{d(h_i,h_j)}{d_{max}}\right)^2, & d(h_i,h_j) \le d_{max}, \\
0, & \text{otherwise}.
\end{cases}
\]

\subsection{Polynomial Reduction Construction}

To reduce the Wildlife Corridor Network Design Problem to the Maximum Flow problem, we construct a directed flow network 
\[
G = (V, E)
\]
where each habitat patch becomes a vertex. For every pair of patches $(h_i, h_j)$ satisfying $d(h_i,h_j) \leq d_{max}$, we add directed edges $(h_i,h_j)$ and $(h_j,h_i)$ with capacity:
\[
c(h_i,h_j) = C_{max}\left(1 - \frac{d(h_i,h_j)}{d_{max}}\right)^2.
\]

The source of the flow network is $h_s$ and the sink is $h_t$.  
Since all $n$ habitat pairs are examined, the construction runs in $O(n^2)$ time.

\subsection{Proof of Correctness}

\textbf{(⇒) If a feasible wildlife corridor configuration exists, then a flow of equal value exists in the constructed network.}  
Any feasible corridor assignment specifies how many animals can move between patches without exceeding corridor capacity. Since these capacities are directly mapped onto edge capacities in $G$, the same movement pattern forms a valid flow from $h_s$ to $h_t$ in the flow network.

\textbf{(⇐) If the maximum flow in $G$ is $f^*$, then there exists a corridor configuration supporting $f^*$ animals/year.}  
A maximum flow solution decomposes into paths from $h_s$ to $h_t$, each respecting edge capacities. Each such path corresponds to a sequence of feasible wildlife corridors. Thus, a real corridor network can support animal movement equal to the maximum flow value.

\textbf{Optimality.}  
By the Max-Flow Min-Cut Theorem, no corridor assignment can support more flow than the minimum cut of $G$. Therefore, the maximum flow solution is optimal.

\textbf{Complexity.}  
Edmonds–Karp runs in:
\[
O(VE^2) = O(n \cdot (n^2)^2) = O(n^5)
\]
in the worst case.  
For sparse corridor networks ($E = O(n)$), the practical complexity is \(O(n^3)\).

\subsection{Algorithm Implementation}

\begin{algorithm}
\caption{Wildlife Corridor Network Design}
\begin{algorithmic}[1]
\STATE \textbf{Input:} Habitats $H$ with locations, $d_{max}$, source $h_s$, target $h_t$
\STATE \textbf{Output:} Maximum animal flow and utilized corridors

\STATE Create flow network $G = (V, E)$
\FOR{each pair $(h_i, h_j)$ in $H \times H$}
    \STATE $d \gets$ distance$(h_i, h_j)$
    \IF{$d \leq d_{max}$}
        \STATE $cap \gets C_{max} \cdot (1 - d/d_{max})^2$
        \STATE Add edges $(h_i, h_j)$ and $(h_j, h_i)$ with capacity $cap$
    \ENDIF
\ENDFOR
\STATE $f^* \gets$ \textsc{EdmondsKarp}$(G, h_s, h_t)$
\RETURN $f^*$ and utilized corridors from residual graph
\end{algorithmic}
\end{algorithm}

\section{Problem 2: DNA Fragment Assembly}

\subsection{Problem Description}

DNA sequencing technologies generate millions of short fragments (reads) from a genome. The assembly problem reconstructs the complete sequence by identifying overlaps between fragments and determining their correct order.

\begin{definition}[DNA Fragment Assembly Problem]
Given:
\begin{itemize}
\item A set $F = \{f_1, f_2, \ldots, f_n\}$ of $n$ DNA fragments (strings over $\{A, C, G, T\}$)
\item Minimum overlap threshold $\ell_{min}$
\end{itemize}
Objective: Find an ordering $\pi$ of fragments that maximizes total overlap, producing the shortest assembled sequence.
\end{definition}

\subsection{Real-World Context}

This problem is central to:
\begin{itemize}
\item Whole genome sequencing (Human Genome Project)
\item Pathogen identification in clinical diagnostics
\item Ancient DNA reconstruction from degraded samples
\item Cancer genomics for identifying mutations
\end{itemize}

Modern sequencing platforms generate millions of fragments, making efficient assembly essential.

\subsection{Abstract Problem Formulation}

We construct a directed overlap graph $G=(V,E)$ where:
\begin{itemize}
\item Each fragment $f_i$ corresponds to a vertex $v_i$,
\item A directed edge $(v_i,v_j)$ exists if the suffix of $f_i$ overlaps the prefix of $f_j$ by at least $\ell_{min}$,
\item The edge weight is the overlap length.
\end{itemize}

The optimal assembly corresponds to a Hamiltonian path that maximizes total overlap, producing the shortest possible superstring.

\subsection{NP-Completeness Proof}

\begin{theorem}
The DNA Fragment Assembly Problem is NP-complete.
\end{theorem}

We prove this using a reduction from the Hamiltonian Path problem.

\textbf{(DNA Assembly $\in$ NP):}  
Given an ordering $\pi$ and claimed overlap value $k$, we can verify:
\begin{itemize}
\item each consecutive pair has overlap $\ge \ell_{min}$, and  
\item the total overlap is at least $k$,  
\end{itemize}
in $O(n\ell)$ time, where $\ell$ is fragment length. Hence, the problem is in NP.

\subsection{NP-Complete Reduction Construction}

Given an instance of Hamiltonian Path on a directed graph $G'=(V',E')$, we construct a DNA assembly instance as follows:

\begin{enumerate}
\item For every vertex $v_i \in V'$, create a DNA fragment  
\[
f_i = A^{(i)}B^{(i)},
\]  
where $A^{(i)}$ is a unique prefix sequence and $B^{(i)}$ is a unique suffix.

\item For each directed edge $(v_i,v_j) \in E'$, enforce an overlap by setting  
\[
B^{(i)} = A^{(j)}
\]  
with length exactly $\ell_{min}$.

\item For all non-edges, ensure  
\[
|B^{(i)} \cap A^{(j)}| < \ell_{min},
\]  
so these fragments cannot legally follow one another in the assembly.
\end{enumerate}

This guarantees that valid overlaps correspond exactly to edges in $G'$, and only those edges.

\subsection{Proof of Correctness}

\textbf{(⇒) If $G'$ has a Hamiltonian path, then the DNA instance has an optimal assembly.}  
Let the Hamiltonian path be:
\[
v_{i_1} \rightarrow v_{i_2} \rightarrow \cdots \rightarrow v_{i_n}.
\]
By construction, each edge in this path corresponds to an enforced overlap of length $\ell_{min}$. Thus, the assembly:
\[
f_{i_1}, f_{i_2}, \ldots, f_{i_n}
\]
achieves total overlap:
\[
(n-1)\ell_{min}.
\]

\textbf{(⇐) If the DNA instance has an assembly with total overlap $(n-1)\ell_{min}$, then $G'$ has a Hamiltonian path.}  
A total overlap of exactly $(n-1)\ell_{min}$ means:
\begin{itemize}
\item every pair of consecutive fragments overlaps by exactly $\ell_{min}$,  
\item no overlap falls below $\ell_{min}$,  
\item therefore every adjacency corresponds to an edge in $G'$.  
\end{itemize}

This produces a permutation of all $n$ vertices where every consecutive pair corresponds to a valid edge — precisely a Hamiltonian path.

Thus, the reduction is correct.

\subsection{Polynomial Time of Reduction}

The reduction creates:
\begin{itemize}
\item $n$ fragments, each of length $O(n)$,
\item overlap assignments for all $n^2$ ordered pairs.
\end{itemize}

Each overlap check or assignment is $O(1)$ or string concatenation of size $O(n)$, yielding a total runtime:
\[
O(n^2).
\]

Therefore, the reduction runs in polynomial time, as required for NP-completeness proofs.

\subsection{Greedy Heuristics}

Since DNA Assembly is NP-complete, exact solutions are impractical for large $n$. We implement three greedy heuristics:

\textbf{1) Simple Greedy:} Choose the next fragment giving maximum immediate overlap.  
Complexity: $O(n^2\ell)$.

\textbf{2) Nearest Neighbor:} Start with the fragment having highest total outgoing overlap, then repeatedly pick the best neighbor.  
Complexity: $O(n^2\ell)$.

\textbf{3) Savings Algorithm:} Uses the sum of current overlap and future potential overlap to choose the next fragment.  
Complexity: $O(n^2\ell)$.

\textbf{Performance Summary:}
\begin{itemize}
\item Simple Greedy: lowest total overlap.
\item Nearest Neighbor: moderate performance.
\item Savings: consistently 20--25\% better than Simple Greedy.
\end{itemize}

\begin{algorithm}
\caption{Nearest Neighbor DNA Assembly}
\begin{algorithmic}[1]
\STATE Compute overlap graph $G$
\FOR{each fragment $f_i$}
    \STATE $connectivity[i] \gets \sum_{j \neq i} overlap(f_i, f_j)$
\ENDFOR
\STATE $current \gets \arg\max_i connectivity[i]$
\STATE $used[current] \gets true$
\WHILE{unassembled fragments remain}
    \STATE $best \gets \arg\max_{j: \neg used[j]} overlap(current, f_j)$
    \STATE Append $f_{best}$ to assembly
    \STATE $used[best] \gets true$; $current \gets best$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Savings Algorithm for DNA Assembly}
\begin{algorithmic}[1]
\STATE Compute overlap graph $G$
\FOR{each fragment $f_i$}
    \STATE $savings[i] \gets \max_{j \neq i} overlap(f_i, f_j)$
\ENDFOR
\STATE $current \gets \arg\max_i savings[i]$
\STATE $used[current] \gets true$
\WHILE{unassembled fragments remain}
    \STATE $best \gets \arg\max_{j: \neg used[j]} (overlap(current, f_j) + savings[j])$
    \STATE Append $f_{best}$ to assembly
    \STATE $used[best] \gets true$; $current \gets best$
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\section{Experimental Results}

\subsection{Experimental Setup}

All experiments were conducted on an Intel Core i7 processor with 16GB RAM, running Ubuntu 24.04. The algorithms were implemented in C++17 with O3 optimization. Each data point represents the average of 10 independent runs.

\subsection{Problem 1: Network Flow Results}

We generated random habitat distributions in a 100km $\times$ 100km region with maximum corridor distance 35km. Networks ranged from 10-50 habitat patches.

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.48\textwidth]{wildlife_corridor_analysis.png}}
\caption{Wildlife corridor experimental results. Top left: Running time with quadratic fit. Top right: Maximum animal flow capacity. Bottom left: Corridor network density. Bottom right: Theoretical vs. actual complexity.}
\label{fig:wildlife}
\end{figure}

Figure \ref{fig:wildlife} shows the empirical running time grows polynomially with problem size, consistent with our theoretical analysis. The quadratic fit suggests $O(n^3)$ behavior in practice, where $n$ is the number of habitats.

\textbf{Key Observations:}
\begin{itemize}
\item For $n = 50$ habitats, the algorithm completes in under 5ms
\item The complexity is dominated by the Edmonds-Karp max flow computation
\item All generated instances with reasonable parameters had feasible solutions
\end{itemize}

\subsection{Problem 2: NP-Complete Results}

We generated synthetic DNA sequences of length 200bp, then extracted 10-40 overlapping fragments of length 15bp each.

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.48\textwidth]{dna_assembly_analysis.png}}
\caption{DNA assembly experimental results. Top left: Running time comparison. Top right: Assembly quality (total overlap). Bottom left: Overlap graph density. Bottom right: Complexity analysis on log scale.}
\label{fig:dna}
\end{figure}

Figure \ref{fig:dna} demonstrates:
\begin{itemize}
\item All three heuristics scale polynomially in practice
\item Savings algorithm consistently produces the best solutions (highest overlap)
\item Nearest Neighbor provides intermediate performance
\item Runtime differences are negligible (<2ms for 40 fragments)
\end{itemize}

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.48\textwidth]{algorithm_comparison.png}}
\caption{Heuristic comparison. Left: Overlap quality across problem sizes. Right: Distribution of solution quality.}
\label{fig:comparison}
\end{figure}

\textbf{Algorithm Performance:}
\begin{itemize}
\item Savings: Uses 20-25\% better overlap than simple greedy on average
\item Nearest Neighbor: Performance between greedy and Savings
\item Computational Cost: Savings is only 2-3x slower than simple greedy
\end{itemize}

\subsection{Scalability Analysis}

Table \ref{tab:scalability} summarizes the scalability of both approaches:

\begin{table}[htbp]
\caption{Scalability Comparison}
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Problem} & \textbf{Size (n)} & \textbf{Time (ms)} & \textbf{Complexity} \\
\hline
Network Flow & 10 & 0.002 & $O(n^3)$ \\
Network Flow & 30 & 0.032 & $O(n^3)$ \\
Network Flow & 50 & 4.8 & $O(n^3)$ \\
\hline
Greedy & 10 & 0.04 & $O(n^2)$ \\
Nearest Neighbor & 10 & 0.05 & $O(n^2)$ \\
Savings & 10 & 0.04 & $O(n^2)$ \\
\hline
Greedy & 40 & 5.2 & $O(n^2)$ \\
Nearest Neighbor & 40 & 6.8 & $O(n^2)$ \\
Savings & 40 & 7.1 & $O(n^2)$ \\
\hline
\end{tabular}
\label{tab:scalability}
\end{center}
\end{table}

\section{Discussion}

\subsection{Practical Implications}

\textbf{Wildlife Conservation:} The network flow approach provides conservation agencies with optimal corridor networks. Real applications include:
\begin{itemize}
\item Yellowstone to Yukon (Y2Y) initiative for grizzly bear connectivity
\item Florida Wildlife Corridor connecting Everglades to Okefenokee
\item African elephant corridors in Kenya and Tanzania
\end{itemize}

\textbf{Genome Assembly:} While modern assemblers use more sophisticated methods, our heuristics demonstrate the fundamental tradeoff between solution quality and computational cost. The Savings algorithm's 20-25\% improvement suggests that lookahead strategies significantly enhance assembly quality.

\subsection{Theoretical Insights}

Our work demonstrates the practical value of theoretical computer science:

\begin{enumerate}
\item \textbf{Polynomial Reductions:} By recognizing wildlife corridor design as a maximum flow problem, we obtain provably optimal solutions efficiently.
\item \textbf{NP-Completeness:} Understanding DNA assembly's computational hardness guides us toward heuristic rather than exact approaches for large instances.
\item \textbf{Algorithm Design:} Sophisticated greedy strategies (Savings) that consider future consequences outperform myopic approaches (Simple Greedy) with negligible additional cost.
\end{enumerate}

\subsection{Limitations and Future Work}

\textbf{Extensions to Wildlife Corridors:}
\begin{itemize}
\item Multi-species corridors with different movement requirements (multi-commodity flow)
\item Time-varying capacities (seasonal migration patterns)
\item Construction costs and budget constraints (min-cost max-flow)
\end{itemize}

\textbf{Improvements to DNA Assembly:}
\begin{itemize}
\item Sequencing errors require error-tolerant overlap detection
\item Repetitive sequences cause ambiguous assemblies
\item Paired-end reads provide additional constraints
\item Modern long-read technologies (PacBio, Nanopore) alter problem structure
\end{itemize}

\section{Conclusion}

This paper presented two real-world problems from conservation ecology and bioinformatics and their algorithmic solutions through polynomial reductions. The Wildlife Corridor Network Design Problem, reduced to Maximum Flow, admits efficient optimal solutions. The DNA Fragment Assembly Problem, proven NP-complete via reduction from Hamiltonian Path, requires heuristic approaches, with the Savings algorithm providing 20-25\% quality improvements.

Our experimental results validate the theoretical complexity analyses and demonstrate that both approaches scale well to realistic problem sizes. The source code and experimental data are available at \url{https://github.com/yourusername/ecology-bioinformatics-algorithms} for reproducibility.

The success of these reductions illustrates a fundamental principle in algorithm design: recognizing problem structure and leveraging well-studied algorithmic techniques can yield both theoretically sound and practically efficient solutions.

\section{Repository and Artifacts}

All code, experimental data, and documentation are available at:

\textbf{GitHub Repository:} \url{https://github.com/yourusername/ecology-bioinformatics-algorithms}

\subsection{Code Files}
\begin{itemize}
\item \texttt{problem1\_network\_flow.cpp} - Wildlife corridor implementation with Edmonds-Karp max flow
\item \texttt{problem2\_np\_complete.cpp} - DNA assembly with three greedy heuristics
\item \texttt{generate\_graphs.py} - Experimental visualization pipeline
\item \texttt{Makefile} - Build automation
\end{itemize}

\subsection{Experimental Artifacts}
\begin{itemize}
\item \texttt{wildlife\_network\_flow\_results.csv} - Timing data for Problem 1
\item \texttt{dna\_assembly\_results.csv} - Algorithm comparison for Problem 2
\item \texttt{*.png} - All experimental plots
\end{itemize}

\subsection{Reproducibility}

All experiments were conducted on Ubuntu 24.04 with g++ (C++17, -O3 optimization) and Python 3.10. To reproduce:

\begin{verbatim}
# Compile programs
make all

# Run experiments and generate graphs
make graphs
\end{verbatim}

Random seeds are fixed for deterministic results. Complete setup instructions are provided in README.md.

\section{Appendix: Code Excerpts}

\subsection{Problem 1: Maximum Flow Implementation}

The following C++ code implements the Edmonds-Karp algorithm for maximum flow:

\begin{lstlisting}
class MaxFlow {
private:
    int n;
    vector<vector<int>> capacity;
    vector<vector<int>> adj;
    
    bool bfs(int source, int sink,
             vector<int>& parent) {
        fill(parent.begin(), parent.end(), -1);
        parent[source] = source;
        queue<pair<int, int>> q;
        q.push(make_pair(source, INT_MAX));
        
        while (!q.empty()) {
            int u = q.front().first;
            int flow = q.front().second;
            q.pop();
            
            for (int v : adj[u]) {
                if (parent[v] == -1 &&
                    capacity[u][v] > 0) {
                    parent[v] = u;
                    int new_flow = min(flow,
                                     capacity[u][v]);
                    if (v == sink) return true;
                    q.push(make_pair(v, new_flow));
                }
            }
        }
        return false;
    }
    
public:
    MaxFlow(int n) : n(n),
        capacity(n, vector<int>(n, 0)),
        adj(n) {}
    
    void addEdge(int u, int v, int cap) {
        if (capacity[u][v] == 0 &&
            capacity[v][u] == 0) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        capacity[u][v] += cap;
    }
    
    int maxflow(int source, int sink) {
        int flow = 0;
        vector<int> parent(n);
        
        while (bfs(source, sink, parent)) {
            int path_flow = INT_MAX;
            for (int v = sink; v != source;
                 v = parent[v]) {
                int u = parent[v];
                path_flow = min(path_flow,
                              capacity[u][v]);
            }
            
            for (int v = sink; v != source;
                 v = parent[v]) {
                int u = parent[v];
                capacity[u][v] -= path_flow;
                capacity[v][u] += path_flow;
            }
            
            flow += path_flow;
        }
        return flow;
    }
};
\end{lstlisting}

\subsection{Problem 2: Savings Greedy Heuristic}

The Savings algorithm provides the best quality among greedy methods:

\begin{lstlisting}
vector<int> savingsAssemble() {
    vector<bool> used(numFragments, false);
    vector<int> order;
    
    // Calculate "savings" for each fragment
    vector<int> savings(numFragments);
    for (int i = 0; i < numFragments; i++) {
        int maxOut = 0;
        for (int j = 0; j < numFragments; j++) {
            if (i != j) {
                maxOut = max(maxOut,
                           overlapGraph[i][j]);
            }
        }
        savings[i] = maxOut;
    }
    
    // Start with fragment with maximum savings
    int current = max_element(savings.begin(),
                            savings.end())
                - savings.begin();
    used[current] = true;
    order.push_back(current);
    
    // Continue assembly
    for (int step = 1; step < numFragments;
         step++) {
        int bestNext = -1;
        int bestScore = -1;
        
        for (int j = 0; j < numFragments; j++) {
            if (!used[j]) {
                // Score = current overlap +
                //         future potential
                int score = overlapGraph[current][j]
                          + savings[j];
                if (score > bestScore) {
                    bestScore = score;
                    bestNext = j;
                }
            }
        }
        
        if (bestNext == -1) {
            for (int j = 0; j < numFragments; j++) {
                if (!used[j]) {
                    bestNext = j;
                    break;
                }
            }
        }
        
        used[bestNext] = true;
        order.push_back(bestNext);
        current = bestNext;
    }
    
    return order;
}
\end{lstlisting}

\section*{Acknowledgment}

The authors thank the course instructors for their guidance and the reviewers for their valuable feedback on this work.

\begin{thebibliography}{00}
\bibitem{ford1956} L. R. Ford and D. R. Fulkerson, ``Maximal flow through a network,'' \textit{Canadian Journal of Mathematics}, vol. 8, pp. 399-404, 1956.

\bibitem{edmonds1972} J. Edmonds and R. M. Karp, ``Theoretical improvements in algorithmic efficiency for network flow problems,'' \textit{Journal of the ACM}, vol. 19, no. 2, pp. 248-264, 1972.

\bibitem{urban2001} D. Urban and T. Keitt, ``Landscape connectivity: A graph-theoretic perspective,'' \textit{Ecology}, vol. 82, no. 5, pp. 1205-1218, 2001.

\bibitem{waterman1995} M. S. Waterman, \textit{Introduction to Computational Biology}. Chapman \& Hall, 1995.

\bibitem{myers2000} E. W. Myers et al., ``A whole-genome assembly of Drosophila,'' \textit{Science}, vol. 287, no. 5461, pp. 2196-2204, 2000.

\bibitem{pevzner2001} P. A. Pevzner, H. Tang, and M. S. Waterman, ``An Eulerian path approach to DNA fragment assembly,'' \textit{Proceedings of the National Academy of Sciences}, vol. 98, no. 17, pp. 9748-9753, 2001.

\bibitem{kececioglu1995} J. Kececioglu and E. W. Myers, ``Combinatorial algorithms for DNA sequence assembly,'' \textit{Algorithmica}, vol. 13, no. 1-2, pp. 7-51, 1995.

\bibitem{garey1979} M. R. Garey and D. S. Johnson, \textit{Computers and Intractability: A Guide to the Theory of NP-Completeness}. W. H. Freeman, 1979.

\bibitem{cormen2009} T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, \textit{Introduction to Algorithms}, 3rd ed. MIT Press, 2009.

\bibitem{ahuja1993} R. K. Ahuja, T. L. Magnanti, and J. B. Orlin, \textit{Network Flows: Theory, Algorithms, and Applications}. Prentice Hall, 1993.
\end{thebibliography}

\end{document}